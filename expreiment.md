# 实验数据
## 代码编号：03281006
- floatingObj_prune函数 思路：
    - 找到符合如下条件的高斯体中心位置，并删除：
        - A.渲染深度要小于先验深度（足够说明先验深度之前存在高斯体的遮挡）
        - B.渲染深度要在高斯体中或者后（渲染深度如果在高斯体中或者在此高斯体后面，足以说明这个高斯体遮挡了渲染，需要删除）
    - 为什么算法有效？
        - 假设不满足条件A，那么应该是这个位置存在未补足的细节，而不是选择删除高斯体，应该用其他方法处理。
        - 假设不满足条件B，说明渲染深度在高斯体的前面，那么我们无法判断这个高斯体是否正确。在其它视角中，这个高斯体可能是正确的
        - 问：如果先验深度面前存在大量遮挡高斯体，你如何保证删除？
        - 答：可以肯定的是，每一次迭代都会删掉一定数量的遮挡高斯体。只要迭代的次数足够多，就可以不断地删除这些遮挡的高斯体
        - 问：你如何保证不会错误删除？
        - 答：如果枚举到的高斯体的深度比渲染深度还要浅，并且先验深度又远大于渲染深度，那么可以认为渲染深度在计算的过程中一定统计了这个高斯体的不透明度，
            并且这个渲染深度是错的。错误的原因，是这个高斯体一定为阻碍渲染深度做出了贡献，那么它肯定就是近相机漂浮物之一，需要删除
- 代码不在优化的过程中执行删除，是为了防止高斯体在训练迭代的过程中变得巨大，因为删除了之后优化器会试图去部族细节，而这个细节处的高斯体不多，所以优化器会尝试使用一个高斯体补足所有细节，这就会导致高斯体变得又大又丑
### 实验编号：M03281006-1
- LLFF数据集，horn的images_4文件内容，使用了新设计的模块
- PSNR:8.6532373
- SSIM:0.2622204
- LPIPS:0.5168151
### 实验编号：M03281006-2
- LLFF数据集，horn的images_4文件内容，无深度约束，普通跑一次
- PSNR:29.3503857
- SSIM:0.9309691
- LPIPS:0.0981247
### 实验编号：M03281006-3
- LLFF数据集，fortress的images_4文件内容，使用了新设计的模块
- PSNR:10.5015745
- SSIM:0.7470842
- LPIPS:0.2407051
### 实验编号：M03281006-4
- LLFF数据集，fortress的images_4文件内容，无深度约束，普通跑一次
- PSNR:32.0723763
- SSIM:0.9283063
- LPIPS:0.0830366
### 实验编号：M03281006-5
- 本质是和M03281006-4一致，但是M03281006-4没有保存29900步，影响代码效率。所以重新训练一次，保存步骤吗，方便后面修改
- PSNR:32.0723763
- SSIM:0.9283063
- LPIPS:0.0830366
### 实验编号：M03281006-6
- 使用room数据集。保存步骤
- PSNR:32.8207932
- SSIM:0.9617723
- LPIPS:0.0841785
### 实验编号：M03281006-7
- 未使用绝对深度约束的高斯删除，room数据集，删除了非常多的高斯体